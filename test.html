<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>On the Margin of Thought</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/common.css">
    <link rel="stylesheet" href="styles/test.css">
</head>
<body>
    <div class="progress-bar" id="progress-bar"></div>
    <div class="section-indicator" id="section-indicator"></div>
    <button class="scroll-to-top" id="scroll-to-top" aria-label="Scroll to top">â†‘</button>
    <header class="site-header">
        <nav>
            <a href="/" class="nav-link">Home</a>
            <button id="theme-toggle" class="toggle-button"></button><span class="theme-indicator" id="theme-indicator"></span>
        </nav>
    </header>
    <div class="container">
        <div class="main-content">
            <article>
                <h1 class="fade-in">On the Margin of Thought</h1>
                <p class="subtitle fade-in">A test essay exploring sidenotes, typography, and the architecture of reading</p>
                <p class="reading-time fade-in" id="reading-time"></p>

                <section class="epigraph fade-in">
                    <p>The margins of a book are the wilderness surrounding the cultivated fields of the text.</p>
                    <footer>â€” Edward Tufte, paraphrased</footer>
                </section>

                <p class="drop-cap">In the beginning there was the margin, and the margin was without form, and void. Then came the scholar with a quill, filling those white spaces with commentary, corrections, and occasionally, drawings of cats.<label for="sn-1" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-1" class="margin-toggle"/>
                <span class="sidenote">Medieval manuscripts are filled with marginal illustrations of cats, often engaged in activities like catching mice, playing instruments, or, inexplicably, riding snails into battle.</span>
                The margin has always been a space for the secondary voice, the whispered aside, the thought that couldn't quite fit in the main flow but demanded to be recorded nonetheless.</p>

                <p>This essay is an experiment in form. It uses what are called <em>sidenotes</em>â€”a technique popularized by Edward Tufte in his beautiful books on data visualization and information design.<label for="sn-2" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-2" class="margin-toggle"/>
                <span class="sidenote">Tufte's books, particularly <em>The Visual Display of Quantitative Information</em> (1983), pioneered many conventions we now take for granted in information design. His use of sidenotes allows readers to access supplementary information without breaking their reading flow.</span>
                Unlike footnotes, which banish related thoughts to the bottom of the page, or endnotes, which exile them to a distant chapter, sidenotes keep everything visible. The eye can travel laterally to consume additional context, then return to the main text without losing its place.</p>

                <h2>The Architecture of Reading</h2>

                <p>Consider how you read this sentence. Your eyes don't move smoothly across the lineâ€”they jump in quick movements called <em>saccades</em>, fixing on certain words while your brain fills in the gaps.<label for="sn-3" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-3" class="margin-toggle"/>
                <span class="sidenote">A saccade typically lasts 20-200 milliseconds. During this movement, vision is essentially suppressedâ€”a phenomenon called saccadic masking. Your brain reconstructs continuous vision from these discrete samples.</span>
                Good typography works with this process, not against it. The width of a column, the spacing between lines, the choice of typefaceâ€”all of these affect how easily your eyes can dance across the page.</p>

                <label for="mn-1" class="margin-toggle">âŠ•</label>
                <input type="checkbox" id="mn-1" class="margin-toggle"/>
                <span class="marginnote">This is a margin noteâ€”similar to a sidenote but without a number. Use these for tangential observations that enhance but aren't essential to the main argument.</span>

                <p>The typeface you're reading now is EB Garamond, a digital revival of the types cut by Claude Garamont in the sixteenth century. Garamond is what typographers call an "old-style" serifâ€”the serifs (those small feet on the letters) are bracketed rather than hairline-thin, and there's relatively low contrast between thick and thin strokes. This makes it highly readable at small sizes and in long passages.</p>

                <p>The line length here is deliberately constrained. Research suggests that optimal line length for reading is between 45 and 75 characters per line.<label for="sn-4" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-4" class="margin-toggle"/>
                <span class="sidenote">This recommendation comes from countless studies on reading comprehension and eye tracking. Lines that are too long make it difficult for the eye to find the next line; lines that are too short interrupt the reading rhythm with too-frequent line breaks.</span>
                Too short, and the eye becomes fatigued from constantly jumping to new lines. Too long, and the eye loses its place when returning from the end of one line to the beginning of the next.</p>

                <h2>On Minimalism</h2>

                <p>There's a kind of quietness that good typography achieves. It doesn't call attention to itself. You don't notice the typeface or the margins or the leadingâ€”you simply read, absorbed in the ideas, unaware of the medium that conveys them.<label for="sn-5" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-5" class="margin-toggle"/>
                <span class="sidenote">Beatrice Warde, in her famous essay "The Crystal Goblet" (1932), argued that typography should be like a crystal wine glassâ€”invisible, allowing the wine (the content) to shine through, rather than a golden goblet that draws attention to itself.</span></p>

                <blockquote>
                    <p>Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.</p>
                </blockquote>

                <p>This principle, from Antoine de Saint-ExupÃ©ry, applies as much to page design as to aircraft design (his original context). Each element on the page should earn its place. The margins are wide not from extravagance but because white space gives the eye rest. The type is large enough to read comfortably but not so large as to feel like a children's book. Every decision is in service of one goal: allowing ideas to travel from the page to the mind with as little friction as possible.</p>

                <h2>The Digital Challenge</h2>

                <p>Sidenotes present an interesting challenge on the web. Unlike a printed book, a webpage must accommodate screens of wildly varying sizesâ€”from the vast expanse of a desktop monitor to the narrow confines of a mobile phone.<label for="sn-6" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-6" class="margin-toggle"/>
                <span class="sidenote">This page uses responsive design. On wide screens, sidenotes float in the margin. On narrow screens, they collapse into toggleable inline elementsâ€”tap the number to reveal them. Try resizing your browser window to see this in action.</span>
                The solution is responsive design: on wide screens, the sidenotes float elegantly in the margin; on narrow screens, they transform into expandable elements that the reader can reveal with a tap.</p>

                <p>This adaptability is both a constraint and an opportunity. The web cannot perfectly replicate the fixed dimensions of a printed page, but it can do things print cannotâ€”dark mode for reading at night, hyperlinks that connect ideas across documents, and (with some JavaScript) interactive elements that respond to the reader's actions.</p>

                <h2>The Details That Delight</h2>

                <p>This page is packed with small touches meant to enhance the reading experience. Look to the top of your screenâ€”a thin progress bar shows how far you've read.<label for="sn-8" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-8" class="margin-toggle"/>
                <span class="sidenote">The progress bar uses a subtle gradient and updates smoothly as you scroll. It adapts its colors to match your chosen themeâ€”red tones in light mode, softer corals in dark mode, and warm siennas in sepia.</span>
                Glance at the left edge of your screen (on desktop)â€”an indicator shows which section you're currently reading.</p>

                <p>Try the theme toggle in the top-right corner. It cycles through three modes: light for bright environments, sepia for a warm paper-like feel, and dark for nighttime reading.<label for="sn-9" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-9" class="margin-toggle"/>
                <span class="sidenote">Sepia mode is particularly kind to the eyes during extended reading sessions. The warm tones reduce blue light exposure and create a feeling reminiscent of aged paper.</span>
                Your preference is saved, so it persists across visits.</p>

                <label for="mn-2" class="margin-toggle">âŠ•</label>
                <input type="checkbox" id="mn-2" class="margin-toggle"/>
                <span class="marginnote">Notice how when you tapped a sidenote number, the parent paragraph briefly glowed? That subtle highlight helps you find your place after reading the note.</span>

                <p>Scroll down past this point and you'll see a button appear in the bottom-right corner. Tap it to glide smoothly back to the top. And if you're on mobile, tap a sidenote numberâ€”watch how it elegantly expands with a buttery animation, then collapses when you tap again.</p>

                <p>Even the way you arrived here was choreographed. When the page loaded, the title, subtitle, and opening content faded in with a gentle staggered animationâ€”nothing jarring, just a quiet welcome.</p>

                <hr>

                <p><span class="newthought">In conclusion,</span> this page is a playgroundâ€”a place to experiment with typography, layout, and the subtle art of presenting ideas clearly. Notice the reading time estimate beneath the subtitle? That sets expectations before you begin. The decorative drop cap on the opening paragraph signals that this is meant to be savored, not skimmed.<label for="sn-10" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-10" class="margin-toggle"/>
                <span class="sidenote">Drop caps have been used since medieval manuscripts. They serve both an aesthetic and practical purposeâ€”marking the beginning of a new section while adding visual elegance to the page.</span></p>

                <p>The sidenotes are working. The margins are breathing. The serif is doing its quiet, elegant work. And somewhere, perhaps, a reader has followed a thought from the main text to the margin and back again, their understanding slightly enriched by that small lateral journey.<label for="sn-11" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="sn-11" class="margin-toggle"/>
                <span class="sidenote">If you've read this far, the experiment has succeeded. The form has served its purpose: carrying ideas from my mind to yours, with the sidenotes providing gentle elaboration along the way.</span></p>

            </article>
            <div class="page-flip-container" id="page-flip-container"></div>
        </div>
    </div>
    <div class="page-indicator" id="page-indicator"></div>
    <button class="page-mode-toggle" id="page-mode-toggle" aria-label="Toggle page flip mode">ðŸ“–</button>
    <div class="swipe-hint" id="swipe-hint"></div>

    <script>
        (function() {
            // Reading progress indicator
            const progressBar = document.getElementById('progress-bar');

            function updateProgress() {
                const scrollTop = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
                progressBar.style.width = progress + '%';
            }

            window.addEventListener('scroll', updateProgress, { passive: true });
            window.addEventListener('resize', updateProgress, { passive: true });
            updateProgress();

            // Reading time estimate
            const article = document.querySelector('article');
            const text = article.innerText;
            const wordCount = text.trim().split(/\s+/).length;
            const readingTime = Math.ceil(wordCount / 200); // 200 words per minute
            document.getElementById('reading-time').textContent = readingTime + ' min read';

            // Three-way theme toggle: light â†’ sepia â†’ dark
            const themeToggle = document.getElementById('theme-toggle');
            const themeIndicator = document.getElementById('theme-indicator');
            const themes = ['light', 'sepia', 'dark'];

            function getTheme() {
                return localStorage.getItem('theme') || 'light';
            }

            function setTheme(theme) {
                document.body.classList.remove('dark-mode', 'sepia-mode');
                if (theme === 'dark') {
                    document.body.classList.add('dark-mode');
                } else if (theme === 'sepia') {
                    document.body.classList.add('sepia-mode');
                }
                localStorage.setItem('theme', theme);
                themeIndicator.textContent = theme;
            }

            // Initialize theme
            setTheme(getTheme());

            themeToggle.addEventListener('click', () => {
                const current = getTheme();
                const nextIndex = (themes.indexOf(current) + 1) % themes.length;
                setTheme(themes[nextIndex]);
            });

            // Sidenote paragraph highlighting
            document.querySelectorAll('label.sidenote-number').forEach(label => {
                label.addEventListener('click', () => {
                    // Find the parent paragraph
                    const paragraph = label.closest('p');
                    if (paragraph) {
                        // Remove any existing highlights
                        document.querySelectorAll('.sidenote-highlight').forEach(el => {
                            el.classList.remove('sidenote-highlight');
                        });
                        // Add highlight to this paragraph
                        paragraph.classList.add('sidenote-highlight');
                        // Remove highlight after 3 seconds
                        setTimeout(() => {
                            paragraph.classList.remove('sidenote-highlight');
                        }, 3000);
                    }
                });
            });

            // Scroll-to-top button
            const scrollToTopBtn = document.getElementById('scroll-to-top');
            const scrollThreshold = 400;

            function updateScrollToTop() {
                if (window.scrollY > scrollThreshold) {
                    scrollToTopBtn.classList.add('visible');
                } else {
                    scrollToTopBtn.classList.remove('visible');
                }
            }

            window.addEventListener('scroll', updateScrollToTop, { passive: true });
            updateScrollToTop();

            scrollToTopBtn.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });

            // Current section indicator
            const sectionIndicator = document.getElementById('section-indicator');
            const headings = document.querySelectorAll('h2');
            const sections = Array.from(headings).map(h => ({
                el: h,
                title: h.textContent
            }));

            function updateSectionIndicator() {
                const scrollY = window.scrollY + 150;
                let currentSection = null;

                for (let i = sections.length - 1; i >= 0; i--) {
                    if (scrollY >= sections[i].el.offsetTop) {
                        currentSection = sections[i].title;
                        break;
                    }
                }

                if (currentSection && window.scrollY > 300) {
                    sectionIndicator.textContent = currentSection;
                    sectionIndicator.classList.add('visible');
                } else {
                    sectionIndicator.classList.remove('visible');
                }
            }

            window.addEventListener('scroll', updateSectionIndicator, { passive: true });
            updateSectionIndicator();

            // ==========================================
            // Page Flip Mode (Mobile Only)
            // ==========================================

            const pageFlipContainer = document.getElementById('page-flip-container');
            const pageIndicator = document.getElementById('page-indicator');
            const pageModeToggle = document.getElementById('page-mode-toggle');
            const swipeHint = document.getElementById('swipe-hint');

            let pages = [];
            let currentPageIndex = 0;
            let isPageMode = false;
            let touchStartX = 0;
            let touchStartY = 0;
            let touchCurrentX = 0;
            let isDragging = false;
            let dragStartTime = 0;

            // Only enable on mobile
            const isMobile = () => window.innerWidth <= 900;

            // Split content into pages based on sections
            function paginateContent() {
                const article = document.querySelector('article');
                const children = Array.from(article.children);

                // Group content into logical pages
                const pageGroups = [];
                let currentGroup = [];

                children.forEach((child, index) => {
                    // Start new page on h2 or after accumulating enough content
                    if (child.tagName === 'H2' && currentGroup.length > 0) {
                        pageGroups.push(currentGroup);
                        currentGroup = [];
                    }

                    // Skip margin-toggle labels and inputs that are standalone
                    if (child.tagName === 'LABEL' || child.tagName === 'INPUT') {
                        // Include with next element
                        currentGroup.push(child);
                        return;
                    }

                    currentGroup.push(child);

                    // Create page after ~3-4 paragraphs or significant content
                    const contentElements = currentGroup.filter(el =>
                        el.tagName === 'P' || el.tagName === 'BLOCKQUOTE' || el.tagName === 'SECTION'
                    ).length;

                    if (contentElements >= 3 && child.tagName !== 'H2') {
                        // Check if next element is not a sidenote/margin related
                        const nextChild = children[index + 1];
                        if (!nextChild || (nextChild.tagName !== 'LABEL' && nextChild.tagName !== 'INPUT' && nextChild.tagName !== 'SPAN')) {
                            pageGroups.push(currentGroup);
                            currentGroup = [];
                        }
                    }
                });

                if (currentGroup.length > 0) {
                    pageGroups.push(currentGroup);
                }

                return pageGroups;
            }

            // Render pages
            function renderPages() {
                const pageGroups = paginateContent();
                pageFlipContainer.innerHTML = '';
                pageIndicator.innerHTML = '';
                pages = [];

                pageGroups.forEach((group, index) => {
                    const page = document.createElement('div');
                    page.className = 'page' + (index === 0 ? ' current' : index === 1 ? ' next' : '');
                    page.dataset.index = index;

                    const content = document.createElement('div');
                    content.className = 'page-content';

                    group.forEach(el => {
                        const clone = el.cloneNode(true);
                        // Remove fade-in class from clones
                        clone.classList.remove('fade-in');
                        content.appendChild(clone);
                    });

                    page.appendChild(content);
                    pageFlipContainer.appendChild(page);
                    pages.push(page);

                    // Create indicator dot
                    const dot = document.createElement('div');
                    dot.className = 'page-dot' + (index === 0 ? ' active' : '');
                    dot.dataset.index = index;
                    dot.addEventListener('click', () => goToPage(index));
                    pageIndicator.appendChild(dot);
                });
            }

            // Update page visibility
            function updatePageVisibility() {
                pages.forEach((page, index) => {
                    page.classList.remove('current', 'next', 'prev', 'flip-complete');
                    if (index === currentPageIndex) {
                        page.classList.add('current');
                    } else if (index === currentPageIndex + 1) {
                        page.classList.add('next');
                    } else if (index < currentPageIndex) {
                        page.classList.add('prev');
                    }
                });

                // Update dots
                document.querySelectorAll('.page-dot').forEach((dot, index) => {
                    dot.classList.toggle('active', index === currentPageIndex);
                });
            }

            // Go to specific page
            function goToPage(index) {
                if (index >= 0 && index < pages.length) {
                    currentPageIndex = index;
                    updatePageVisibility();
                }
            }

            // Toggle page mode
            function togglePageMode() {
                if (!isMobile()) return;

                isPageMode = !isPageMode;
                document.body.classList.toggle('page-mode', isPageMode);

                if (isPageMode) {
                    renderPages();
                    currentPageIndex = 0;
                    updatePageVisibility();
                    // Show swipe hint on first enable
                    if (!localStorage.getItem('pageFlipHintShown')) {
                        swipeHint.style.display = 'block';
                        localStorage.setItem('pageFlipHintShown', 'true');
                    }
                }

                localStorage.setItem('pageMode', isPageMode ? 'true' : 'false');
            }

            // Touch handlers for page flip
            function handleTouchStart(e) {
                if (!isPageMode) return;

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchCurrentX = touchStartX;
                isDragging = true;
                dragStartTime = Date.now();

                const currentPage = pages[currentPageIndex];
                if (currentPage) {
                    currentPage.classList.add('flipping');
                }
            }

            function handleTouchMove(e) {
                if (!isPageMode || !isDragging) return;

                touchCurrentX = e.touches[0].clientX;
                const touchCurrentY = e.touches[0].clientY;

                // Calculate deltas
                const deltaX = touchCurrentX - touchStartX;
                const deltaY = touchCurrentY - touchStartY;

                // If scrolling more vertically, let it scroll
                if (Math.abs(deltaY) > Math.abs(deltaX) * 1.5) {
                    return;
                }

                // Prevent default only for horizontal swipes
                if (Math.abs(deltaX) > 10) {
                    e.preventDefault();
                }

                const currentPage = pages[currentPageIndex];
                if (!currentPage) return;

                // Calculate rotation based on drag distance
                const screenWidth = window.innerWidth;
                const dragPercent = Math.max(-1, Math.min(1, deltaX / (screenWidth * 0.5)));

                if (deltaX < 0 && currentPageIndex < pages.length - 1) {
                    // Swiping left (next page) - rotate current page
                    const rotation = dragPercent * 90; // Max 90 degrees
                    currentPage.style.transform = `rotateY(${rotation}deg)`;
                    currentPage.style.boxShadow = `${-dragPercent * 10}px 0 ${20 - dragPercent * 10}px rgba(0, 0, 0, ${0.1 - dragPercent * 0.1})`;
                } else if (deltaX > 0 && currentPageIndex > 0) {
                    // Swiping right (prev page) - rotate previous page back
                    const prevPage = pages[currentPageIndex - 1];
                    if (prevPage) {
                        prevPage.classList.add('flipping');
                        const rotation = -180 + (dragPercent * 90);
                        prevPage.style.transform = `rotateY(${rotation}deg)`;
                    }
                }
            }

            function handleTouchEnd(e) {
                if (!isPageMode || !isDragging) return;

                isDragging = false;
                const deltaX = touchCurrentX - touchStartX;
                const dragDuration = Date.now() - dragStartTime;
                const velocity = Math.abs(deltaX) / dragDuration;

                const currentPage = pages[currentPageIndex];
                if (currentPage) {
                    currentPage.classList.remove('flipping');
                    currentPage.style.transform = '';
                    currentPage.style.boxShadow = '';
                }

                // Threshold for page flip: either distance or velocity
                const threshold = window.innerWidth * 0.25;
                const velocityThreshold = 0.5;

                if (deltaX < -threshold || (deltaX < -50 && velocity > velocityThreshold)) {
                    // Next page
                    if (currentPageIndex < pages.length - 1) {
                        currentPageIndex++;
                        updatePageVisibility();
                    }
                } else if (deltaX > threshold || (deltaX > 50 && velocity > velocityThreshold)) {
                    // Previous page
                    if (currentPageIndex > 0) {
                        const prevPage = pages[currentPageIndex - 1];
                        if (prevPage) {
                            prevPage.classList.remove('flipping');
                            prevPage.style.transform = '';
                        }
                        currentPageIndex--;
                        updatePageVisibility();
                    }
                } else {
                    // Snap back
                    if (currentPageIndex > 0) {
                        const prevPage = pages[currentPageIndex - 1];
                        if (prevPage) {
                            prevPage.classList.remove('flipping');
                            prevPage.style.transform = '';
                        }
                    }
                }
            }

            // Initialize page mode
            if (isMobile()) {
                pageModeToggle.addEventListener('click', togglePageMode);

                pageFlipContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
                pageFlipContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                pageFlipContainer.addEventListener('touchend', handleTouchEnd, { passive: true });

                // Restore page mode preference
                if (localStorage.getItem('pageMode') === 'true') {
                    togglePageMode();
                }
            }

            // Handle resize
            window.addEventListener('resize', () => {
                if (!isMobile() && isPageMode) {
                    document.body.classList.remove('page-mode');
                    isPageMode = false;
                }
            });
        })();
    </script>
</body>
</html>
